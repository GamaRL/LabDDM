%% %% %% %%
%%
%% Parte B de la práctica
%%
%% %% %% %%

\documentclass[../procedimientos.tex]{subfiles}
\graphicspath{{\subfix{../../images/}}}

\begin{document}
\clearpage
\subsection{Parte B}
\subsubsection{Instrucciones}
Diseñar e implementar un circuito digital que mediante una señal de control 
$C$ pueda seleccionar el tipo de conversión de código: con $C=1$, GRAY a 
BINARIO y con $C=0$, BINARIO a GRAY. El código es de tres bits.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{b_instruction}
  \caption{Ejercicio B}
  \label{fig:b_inst}
\end{figure}

\subsubsection{Análisis}
Primero, es importante plantear la tabla de verdad del problema. Para este 
caso, se tienen  tres entradas: $c$, $x$, $y$ y $z$. De los anteriores, para 
la representación de 3 bits del número, únicamente se consideran $x$, $y$ y 
$z$; mientras qeu $c$ únicamente se considera como una bandera. Por otra 
parte, la salida está compuesta de tres bits: $f_1$ (bit más signiticativo), 
$f_2$ y $f_3$ (bit menos signifivativo).

\begin{table}[H]
  \centering
  \begin{tabular}{cccc|ccc}
    \hline
    $c$ & $x$ & $y$ & $z$ & $f_1$ & $f_2$ & $f_3$\\
    \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0\\
    0 & 0 & 0 & 1 & 0 & 0 & 1\\
    0 & 0 & 1 & 0 & 0 & 1 & 1\\
    0 & 0 & 1 & 1 & 0 & 1 & 0\\
    0 & 1 & 0 & 0 & 1 & 1 & 0\\
    0 & 1 & 0 & 1 & 1 & 1 & 1\\
    0 & 1 & 1 & 0 & 1 & 0 & 1\\
    0 & 1 & 1 & 1 & 1 & 0 & 0\\
    1 & 0 & 0 & 0 & 0 & 0 & 0\\
    1 & 0 & 0 & 1 & 0 & 0 & 1\\
    1 & 0 & 1 & 0 & 0 & 1 & 1\\
    1 & 0 & 1 & 1 & 0 & 1 & 0\\
    1 & 1 & 0 & 0 & 1 & 1 & 1\\
    1 & 1 & 0 & 1 & 1 & 1 & 0\\
    1 & 1 & 1 & 0 & 1 & 0 & 0\\
    1 & 1 & 1 & 1 & 1 & 0 & 1\\
    \hline
  \end{tabular}
  \caption{Tabla de verdad del problema (Sección B)}
  \label{tab:tv_b}
\end{table}

La tabla de verdad descrita anteriormente, se describe el comportamiento de 
tres funciones lógicas: $f_1(cxyz)$, $f_2(cxyz)$ y $f_3(cxyz)$. Para deducir 
los circuitos a utilizar, se utilizará la forma canónica \textit{SOP} y a 
través de una reducción se simplificará la expresión, tal como se muestra a 
continuación.

Para $f_1(cxyz)$, se tiene la siguiente forma canónica:
\begin{equation*}
  f_1(cxyz) = \sum_m (4, 5, 6, 7, 12, 13, 14, 15)
\end{equation*}

Desarrollando la expresión:
\begin{align*}
  f_1(cxyz) &= \nt{c}x\nt{y}\nt{z} + \nt{c}x\nt{y}z + \nt{c}xy\nt{z} + 
  \nt{c}xyz + cx\nt{y}\nt{z} + cx\nt{y}z + cxy\nt{z} + cxyz\\
  &= x(\nt{c}\nt{y}\nt{z} + \nt{c}\nt{y}z + \nt{c}y\nt{z} + \nt{c}yz + 
  c\nt{y}\nt{z} + c\nt{y}z + cy\nt{z} + cyz)\\
  &= x(1)\\
  &= x
\end{align*}
\begin{equation*}
  \boxed{
    \therefore f_1(cxyz) = x
  }
\end{equation*}

Continuando con el cálculo de $f_2(cxyz)$, se tiene la siguiente forma 
canónica:
\begin{equation*}
  f_2(cxyz) = \sum_m (2, 3, 4, 5, 10, 11, 12, 13)
\end{equation*}

Desarrollando la expresión:
\begin{align*}
  f_2(cxyz) &= \nt{c}\nt{x}y\nt{z} + \nt{c}\nt{x}yz + \nt{c}x\nt{y}\nt{z} + 
  \nt{c}x\nt{y}z + c\nt{x}y\nt{z} + c\nt{x}yz + cx\nt{y}\nt{z} + cx\nt{y}z\\
  &= (\nt{c}\nt{x}y\nt{z} + \nt{c}\nt{x}yz) + (\nt{c}x\nt{y}\nt{z} + 
  \nt{c}x\nt{y}z) + (c\nt{x}y\nt{z} + c\nt{x}yz) + (cx\nt{y}\nt{z} + 
  cx\nt{y}z)\\
  &= \nt{c}\nt{x}y + \nt{c}x\nt{y} + c\nt{x}y + cx\nt{y}\\
  &= (\nt{c}\nt{x}y + c\nt{x}y) + (\nt{c}x\nt{y} + cx\nt{y})\\
  &= \nt{x}y + x\nt{y}\\
  &= x \oplus y
\end{align*}
\begin{equation*}
  \boxed{
    \therefore f_2(cxyz) = x \oplus y
  }
\end{equation*}

Finalmente, continuando con el cálculo de $f_3(cxyz)$, se tiene la siguiente 
forma canónica:
\begin{equation*}
  f_3(cxyz) = \sum_m (1, 2, 5, 6, 9, 10, 12, 15)
\end{equation*}

Desarrollando la expresión:
\begin{align*}
  f_3(cxyz) &= \nt{c}\nt{x}\nt{y}z + \nt{c}\nt{x}y\nt{z} + \nt{c}x\nt{y}z + 
  \nt{c}xy\nt{z} + c\nt{x}\nt{y}z + c\nt{x}y\nt{z} + cx\nt{y}\nt{z} + cxyz\\
  &= (\nt{c}\nt{x}\nt{y}z + c\nt{x}\nt{y}z) + (\nt{c}\nt{x}y\nt{z} + 
  c\nt{x}y\nt{z}) + (\nt{c}x\nt{y}z + \nt{c}xy\nt{z} + cx\nt{y}\nt{z} + 
  cxyz)\\
  &= \nt{x}\nt{y}z + \nt{x}y\nt{z} + x(\nt{c}\nt{y}z + \nt{c}y\nt{z} + 
  c\nt{y}\nt{z} + cyz)\\
  &= \nt{x}(\nt{y}z + y\nt{z}) + x(\nt{c}(\nt{y}z + y\nt{z}) + c(\nt{y}\nt{z} 
  + yz))\\
  &= \nt{x}(y \oplus z) + x(\nt{c}(y \oplus z) + c(y \odot z))\\
  &= \nt{x}(y \oplus z) + x(c \oplus (y \oplus z))
\end{align*}
\begin{equation*}
  \boxed{
    \therefore f_3(cxyz) = \nt{x}(y \oplus z) + x(c \oplus (y \oplus z))
  }
\end{equation*}

\subsubsection{Implementación en Quartus}
Para la implementación en la plataforma \textit{Quartus II}, se hizo uso de 
los siguientes diagramas de bloques para implementar $f_1(cxyz)$, $f_2(cxyz)$ 
y $f_3(cxyz)$.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{b_f1}
  \caption{Implementación de $f_1(cxyz)$ (Sección B)}
  \label{fig:b_f1}
\end{figure}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{b_f2}
  \caption{Implementación de $f_2(cxyz)$ (Sección B)}
  \label{fig:b_f2}
\end{figure}
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{b_f3}
  \caption{Implementación de $f_3(cxyz)$ (Sección B)}
  \label{fig:b_f3}
\end{figure}

Adicionalmente, cada uno de estos bloques se estableció como un símbolo para 
posteriormente unirse todo en un ``bloque principal'', el cual se muestra a 
continuación.
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{b_complete}
  \caption{Implementación completa (Sección B)}
  \label{fig:b_complete}
\end{figure}

De igual forma que en el sección anterior, se hizo uso de un archivo 
\textit{University Program VWF} para simular el sistema, el resultado fue el 
siguiente:
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{b_sim}
  \caption{Simulación del sistema (Sección B)}
  \label{fig:b_sim}
\end{figure}

El cronograma obtenido en la simulación de la Figura \ref{fig:b_sim} describe 
el comportamiento establecido en la Tabla \ref{tab:tv_b}.

\subsection{Ejecución en la FPGA}
Para poder cargar el programa en la tarjeta de desarrollo, fue importante 
investigar los pines para tomar las entradas y mostrar las salidas 
correctamente. Los pines utilizados se muestran en la Figura 
\ref{fig:b_complete}. Para las entradas, se utilizaron los pines: PIN\_C12, 
PIN\_D12, PIN\_C11 y PIN\_C10 (del bit más significativo al menos 
significativo, respectivamente). Por otro lado, para las salidas se ocuparon 
los pines: PIN\_A10, PIN\_A9 y PIN\_A8 (del bit más significativo al menos 
significativo, respectivamente).

Posteriormente, se volvió a compilar el proyecto para tener en cuenta la 
asignación de pines realizada previamente. Se abrió la ventana 
\textit{Programmer} y se cargó el archivo \textit{.sof}. A continuación, se 
muestran algunos casos de prueba.
\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \caption{Caso de prueba 0111 (7)}
    \label{fig:b_tarj_1}
    \includegraphics[width=\textwidth]{b_tarj_1}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \caption{Caso de prueba 1100 (12)}
    \label{fig:b_tarj_2}
    \includegraphics[width=\textwidth]{b_tarj_2}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \caption{Caso de prueba 0100 (4)}
    \label{fig:b_tarj_3}
    \includegraphics[width=\textwidth]{b_tarj_3}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\textwidth}
    \centering
    \caption{Caso de prueba 1110 (14)}
    \label{fig:b_tarj_4}
    \includegraphics[width=\textwidth]{b_tarj_4}
  \end{subfigure}
  \caption{Casos de prueba (Sección B)}
\end{figure}

Los casos de prueba se comportan según lo esperado:
\begin{itemize}
  \item Para el caso de \ref{fig:b_tarj_1}: El número $111_{(b)}$ es 
    $100_{(g)}$.
  \item Para el caso de \ref{fig:b_tarj_2}: El número $100_{(g)}$ es 
    $111_{(b)}$.
  \item Para el caso de \ref{fig:b_tarj_3}: El número $100_{(b)}$ es 
    $110_{(g)}$.
  \item Para el caso de \ref{fig:b_tarj_4}: El número $100_{(g)}$ es 
    $111_{(b)}$.
\end{itemize}

El caso de prueba de la Figura \ref{fig:b_tarj_2} es inverso al caso de prueba 
de la Figura \ref{fig:b_tarj_1} y el caso de prueba de la Figura 
\ref{fig:b_tarj_4} es inverso al caso de prueba de la Figura 
\ref{fig:b_tarj_3}. Entonces, con los casos de prueba se verifica el 
comportamiento en ambas direcciones del sistema de conversión.
\end{document}

